{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nconst utils_1 = require(\"./utils\");\n/**\n * Returns true if the bloom is a valid bloom\n * @param bloom The bloom\n */\nfunction isBloom(bloom) {\n  if (typeof bloom !== 'string') {\n    return false;\n  }\n  if (!/^(0x)?[0-9a-f]{512}$/i.test(bloom)) {\n    return false;\n  }\n  if (/^(0x)?[0-9a-f]{512}$/.test(bloom) || /^(0x)?[0-9A-F]{512}$/.test(bloom)) {\n    return true;\n  }\n  return false;\n}\nexports.isBloom = isBloom;\n/**\n * Returns true if the value is part of the given bloom\n * note: false positives are possible.\n * @param bloom encoded bloom\n * @param value The value\n */\nfunction isInBloom(bloom, value) {\n  if (typeof value === 'object' && value.constructor === Uint8Array) {\n    value = utils_1.bytesToHex(value);\n  }\n  const hash = utils_1.keccak256(value).replace('0x', '');\n  for (let i = 0; i < 12; i += 4) {\n    // calculate bit position in bloom filter that must be active\n    const bitpos = (parseInt(hash.substr(i, 2), 16) << 8) + parseInt(hash.substr(i + 2, 2), 16) & 2047;\n    // test if bitpos in bloom is active\n    const code = codePointToInt(bloom.charCodeAt(bloom.length - 1 - Math.floor(bitpos / 4)));\n    const offset = 1 << bitpos % 4;\n    if ((code & offset) !== offset) {\n      return false;\n    }\n  }\n  return true;\n}\nexports.isInBloom = isInBloom;\n/**\n * Code points to int\n * @param codePoint The code point\n */\nfunction codePointToInt(codePoint) {\n  if (codePoint >= 48 && codePoint <= 57) {\n    /* ['0'..'9'] -> [0..9] */\n    return codePoint - 48;\n  }\n  if (codePoint >= 65 && codePoint <= 70) {\n    /* ['A'..'F'] -> [10..15] */\n    return codePoint - 55;\n  }\n  if (codePoint >= 97 && codePoint <= 102) {\n    /* ['a'..'f'] -> [10..15] */\n    return codePoint - 87;\n  }\n  throw new Error('invalid bloom');\n}\n/**\n * Returns true if the ethereum users address is part of the given bloom.\n * note: false positives are possible.\n * @param bloom encoded bloom\n * @param address the address to test\n */\nfunction isUserEthereumAddressInBloom(bloom, ethereumAddress) {\n  if (!isBloom(bloom)) {\n    throw new Error('Invalid bloom given');\n  }\n  if (!isAddress(ethereumAddress)) {\n    throw new Error(`Invalid ethereum address given: \"${ethereumAddress}\"`);\n  }\n  // you have to pad the ethereum address to 32 bytes\n  // else the bloom filter does not work\n  // this is only if your matching the USERS\n  // ethereum address. Contract address do not need this\n  // hence why we have 2 methods\n  // (0x is not in the 2nd parameter of padleft so 64 chars is fine)\n  const address = utils_1.padLeft(ethereumAddress, 64);\n  return isInBloom(bloom, address);\n}\nexports.isUserEthereumAddressInBloom = isUserEthereumAddressInBloom;\n/**\n * Returns true if the contract address is part of the given bloom.\n * note: false positives are possible.\n * @param bloom encoded bloom\n * @param contractAddress the contract address to test\n */\nfunction isContractAddressInBloom(bloom, contractAddress) {\n  if (!isBloom(bloom)) {\n    throw new Error('Invalid bloom given');\n  }\n  if (!isAddress(contractAddress)) {\n    throw new Error(`Invalid contract address given: \"${contractAddress}\"`);\n  }\n  return isInBloom(bloom, contractAddress);\n}\nexports.isContractAddressInBloom = isContractAddressInBloom;\n/**\n * Returns true if the topic is part of the given bloom.\n * note: false positives are possible.\n * @param bloom encoded bloom\n * @param topic the topic encoded hex\n */\nfunction isTopicInBloom(bloom, topic) {\n  if (!isBloom(bloom)) {\n    throw new Error('Invalid bloom given');\n  }\n  if (!isTopic(topic)) {\n    throw new Error('Invalid topic');\n  }\n  return isInBloom(bloom, topic);\n}\nexports.isTopicInBloom = isTopicInBloom;\n/**\n * Checks if its a valid topic\n * @param topic encoded hex topic\n */\nfunction isTopic(topic) {\n  if (typeof topic !== 'string') {\n    return false;\n  }\n  if (!/^(0x)?[0-9a-f]{64}$/i.test(topic)) {\n    return false;\n  } else if (/^(0x)?[0-9a-f]{64}$/.test(topic) || /^(0x)?[0-9A-F]{64}$/.test(topic)) {\n    return true;\n  }\n  return false;\n}\nexports.isTopic = isTopic;\n/**\n * Is valid address\n * @param address The address\n */\nfunction isAddress(address) {\n  if (typeof address !== 'string') {\n    return false;\n  }\n  if (address.match(/^(0x)?[0-9a-fA-F]{40}$/)) {\n    return true;\n  }\n  if (address.match(/^XE[0-9]{2}[0-9A-Za-z]{30,31}$/)) {\n    return true;\n  }\n  return false;\n}\nexports.isAddress = isAddress;","map":{"version":3,"names":["Object","defineProperty","exports","value","utils_1","require","isBloom","bloom","test","isInBloom","constructor","Uint8Array","bytesToHex","hash","keccak256","replace","i","bitpos","parseInt","substr","code","codePointToInt","charCodeAt","length","Math","floor","offset","codePoint","Error","isUserEthereumAddressInBloom","ethereumAddress","isAddress","address","padLeft","isContractAddressInBloom","contractAddress","isTopicInBloom","topic","isTopic","match"],"sources":["/Users/tanvisangale/Documents/Project2/Healthcare System/node_modules/ethereum-bloom-filters/dist/index.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst utils_1 = require(\"./utils\");\n/**\n * Returns true if the bloom is a valid bloom\n * @param bloom The bloom\n */\nfunction isBloom(bloom) {\n    if (typeof bloom !== 'string') {\n        return false;\n    }\n    if (!/^(0x)?[0-9a-f]{512}$/i.test(bloom)) {\n        return false;\n    }\n    if (/^(0x)?[0-9a-f]{512}$/.test(bloom) ||\n        /^(0x)?[0-9A-F]{512}$/.test(bloom)) {\n        return true;\n    }\n    return false;\n}\nexports.isBloom = isBloom;\n/**\n * Returns true if the value is part of the given bloom\n * note: false positives are possible.\n * @param bloom encoded bloom\n * @param value The value\n */\nfunction isInBloom(bloom, value) {\n    if (typeof value === 'object' && value.constructor === Uint8Array) {\n        value = utils_1.bytesToHex(value);\n    }\n    const hash = utils_1.keccak256(value).replace('0x', '');\n    for (let i = 0; i < 12; i += 4) {\n        // calculate bit position in bloom filter that must be active\n        const bitpos = ((parseInt(hash.substr(i, 2), 16) << 8) +\n            parseInt(hash.substr(i + 2, 2), 16)) &\n            2047;\n        // test if bitpos in bloom is active\n        const code = codePointToInt(bloom.charCodeAt(bloom.length - 1 - Math.floor(bitpos / 4)));\n        const offset = 1 << bitpos % 4;\n        if ((code & offset) !== offset) {\n            return false;\n        }\n    }\n    return true;\n}\nexports.isInBloom = isInBloom;\n/**\n * Code points to int\n * @param codePoint The code point\n */\nfunction codePointToInt(codePoint) {\n    if (codePoint >= 48 && codePoint <= 57) {\n        /* ['0'..'9'] -> [0..9] */\n        return codePoint - 48;\n    }\n    if (codePoint >= 65 && codePoint <= 70) {\n        /* ['A'..'F'] -> [10..15] */\n        return codePoint - 55;\n    }\n    if (codePoint >= 97 && codePoint <= 102) {\n        /* ['a'..'f'] -> [10..15] */\n        return codePoint - 87;\n    }\n    throw new Error('invalid bloom');\n}\n/**\n * Returns true if the ethereum users address is part of the given bloom.\n * note: false positives are possible.\n * @param bloom encoded bloom\n * @param address the address to test\n */\nfunction isUserEthereumAddressInBloom(bloom, ethereumAddress) {\n    if (!isBloom(bloom)) {\n        throw new Error('Invalid bloom given');\n    }\n    if (!isAddress(ethereumAddress)) {\n        throw new Error(`Invalid ethereum address given: \"${ethereumAddress}\"`);\n    }\n    // you have to pad the ethereum address to 32 bytes\n    // else the bloom filter does not work\n    // this is only if your matching the USERS\n    // ethereum address. Contract address do not need this\n    // hence why we have 2 methods\n    // (0x is not in the 2nd parameter of padleft so 64 chars is fine)\n    const address = utils_1.padLeft(ethereumAddress, 64);\n    return isInBloom(bloom, address);\n}\nexports.isUserEthereumAddressInBloom = isUserEthereumAddressInBloom;\n/**\n * Returns true if the contract address is part of the given bloom.\n * note: false positives are possible.\n * @param bloom encoded bloom\n * @param contractAddress the contract address to test\n */\nfunction isContractAddressInBloom(bloom, contractAddress) {\n    if (!isBloom(bloom)) {\n        throw new Error('Invalid bloom given');\n    }\n    if (!isAddress(contractAddress)) {\n        throw new Error(`Invalid contract address given: \"${contractAddress}\"`);\n    }\n    return isInBloom(bloom, contractAddress);\n}\nexports.isContractAddressInBloom = isContractAddressInBloom;\n/**\n * Returns true if the topic is part of the given bloom.\n * note: false positives are possible.\n * @param bloom encoded bloom\n * @param topic the topic encoded hex\n */\nfunction isTopicInBloom(bloom, topic) {\n    if (!isBloom(bloom)) {\n        throw new Error('Invalid bloom given');\n    }\n    if (!isTopic(topic)) {\n        throw new Error('Invalid topic');\n    }\n    return isInBloom(bloom, topic);\n}\nexports.isTopicInBloom = isTopicInBloom;\n/**\n * Checks if its a valid topic\n * @param topic encoded hex topic\n */\nfunction isTopic(topic) {\n    if (typeof topic !== 'string') {\n        return false;\n    }\n    if (!/^(0x)?[0-9a-f]{64}$/i.test(topic)) {\n        return false;\n    }\n    else if (/^(0x)?[0-9a-f]{64}$/.test(topic) ||\n        /^(0x)?[0-9A-F]{64}$/.test(topic)) {\n        return true;\n    }\n    return false;\n}\nexports.isTopic = isTopic;\n/**\n * Is valid address\n * @param address The address\n */\nfunction isAddress(address) {\n    if (typeof address !== 'string') {\n        return false;\n    }\n    if (address.match(/^(0x)?[0-9a-fA-F]{40}$/)) {\n        return true;\n    }\n    if (address.match(/^XE[0-9]{2}[0-9A-Za-z]{30,31}$/)) {\n        return true;\n    }\n    return false;\n}\nexports.isAddress = isAddress;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script"}