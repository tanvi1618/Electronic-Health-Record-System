{"ast":null,"code":"/**\n * Multihash implementation in JavaScript.\n *\n * @module multihash\n */\n'use strict';\n\nconst {\n  Buffer\n} = require('buffer');\nconst multibase = require('multibase');\nconst varint = require('varint');\nconst cs = require('./constants');\nexports.names = cs.names;\nexports.codes = cs.codes;\nexports.defaultLengths = cs.defaultLengths;\n\n/**\n * Convert the given multihash to a hex encoded string.\n *\n * @param {Buffer} hash\n * @returns {string}\n */\nexports.toHexString = function toHexString(hash) {\n  if (!Buffer.isBuffer(hash)) {\n    throw new Error('must be passed a buffer');\n  }\n  return hash.toString('hex');\n};\n\n/**\n * Convert the given hex encoded string to a multihash.\n *\n * @param {string} hash\n * @returns {Buffer}\n */\nexports.fromHexString = function fromHexString(hash) {\n  return Buffer.from(hash, 'hex');\n};\n\n/**\n * Convert the given multihash to a base58 encoded string.\n *\n * @param {Buffer} hash\n * @returns {string}\n */\nexports.toB58String = function toB58String(hash) {\n  if (!Buffer.isBuffer(hash)) {\n    throw new Error('must be passed a buffer');\n  }\n  return multibase.encode('base58btc', hash).toString().slice(1);\n};\n\n/**\n * Convert the given base58 encoded string to a multihash.\n *\n * @param {string|Buffer} hash\n * @returns {Buffer}\n */\nexports.fromB58String = function fromB58String(hash) {\n  let encoded = hash;\n  if (Buffer.isBuffer(hash)) {\n    encoded = hash.toString();\n  }\n  return multibase.decode('z' + encoded);\n};\n\n/**\n * Decode a hash from the given multihash.\n *\n * @param {Buffer} buf\n * @returns {{code: number, name: string, length: number, digest: Buffer}} result\n */\nexports.decode = function decode(buf) {\n  if (!Buffer.isBuffer(buf)) {\n    throw new Error('multihash must be a Buffer');\n  }\n  if (buf.length < 2) {\n    throw new Error('multihash too short. must be > 2 bytes.');\n  }\n  const code = varint.decode(buf);\n  if (!exports.isValidCode(code)) {\n    throw new Error(`multihash unknown function code: 0x${code.toString(16)}`);\n  }\n  buf = buf.slice(varint.decode.bytes);\n  const len = varint.decode(buf);\n  if (len < 0) {\n    throw new Error(`multihash invalid length: ${len}`);\n  }\n  buf = buf.slice(varint.decode.bytes);\n  if (buf.length !== len) {\n    throw new Error(`multihash length inconsistent: 0x${buf.toString('hex')}`);\n  }\n  return {\n    code: code,\n    name: cs.codes[code],\n    length: len,\n    digest: buf\n  };\n};\n\n/**\n *  Encode a hash digest along with the specified function code.\n *\n * > **Note:** the length is derived from the length of the digest itself.\n *\n * @param {Buffer} digest\n * @param {string|number} code\n * @param {number} [length]\n * @returns {Buffer}\n */\nexports.encode = function encode(digest, code, length) {\n  if (!digest || code === undefined) {\n    throw new Error('multihash encode requires at least two args: digest, code');\n  }\n\n  // ensure it's a hashfunction code.\n  const hashfn = exports.coerceCode(code);\n  if (!Buffer.isBuffer(digest)) {\n    throw new Error('digest should be a Buffer');\n  }\n  if (length == null) {\n    length = digest.length;\n  }\n  if (length && digest.length !== length) {\n    throw new Error('digest length should be equal to specified length.');\n  }\n  return Buffer.concat([Buffer.from(varint.encode(hashfn)), Buffer.from(varint.encode(length)), digest]);\n};\n\n/**\n * Converts a hash function name into the matching code.\n * If passed a number it will return the number if it's a valid code.\n * @param {string|number} name\n * @returns {number}\n */\nexports.coerceCode = function coerceCode(name) {\n  let code = name;\n  if (typeof name === 'string') {\n    if (cs.names[name] === undefined) {\n      throw new Error(`Unrecognized hash function named: ${name}`);\n    }\n    code = cs.names[name];\n  }\n  if (typeof code !== 'number') {\n    throw new Error(`Hash function code should be a number. Got: ${code}`);\n  }\n  if (cs.codes[code] === undefined && !exports.isAppCode(code)) {\n    throw new Error(`Unrecognized function code: ${code}`);\n  }\n  return code;\n};\n\n/**\n * Checks wether a code is part of the app range\n *\n * @param {number} code\n * @returns {boolean}\n */\nexports.isAppCode = function appCode(code) {\n  return code > 0 && code < 0x10;\n};\n\n/**\n * Checks whether a multihash code is valid.\n *\n * @param {number} code\n * @returns {boolean}\n */\nexports.isValidCode = function validCode(code) {\n  if (exports.isAppCode(code)) {\n    return true;\n  }\n  if (cs.codes[code]) {\n    return true;\n  }\n  return false;\n};\n\n/**\n * Check if the given buffer is a valid multihash. Throws an error if it is not valid.\n *\n * @param {Buffer} multihash\n * @returns {undefined}\n * @throws {Error}\n */\nfunction validate(multihash) {\n  exports.decode(multihash); // throws if bad.\n}\n\nexports.validate = validate;\n\n/**\n * Returns a prefix from a valid multihash. Throws an error if it is not valid.\n *\n * @param {Buffer} multihash\n * @returns {undefined}\n * @throws {Error}\n */\nexports.prefix = function prefix(multihash) {\n  validate(multihash);\n  return multihash.slice(0, 2);\n};","map":{"version":3,"names":["Buffer","require","multibase","varint","cs","exports","names","codes","defaultLengths","toHexString","hash","isBuffer","Error","toString","fromHexString","from","toB58String","encode","slice","fromB58String","encoded","decode","buf","length","code","isValidCode","bytes","len","name","digest","undefined","hashfn","coerceCode","concat","isAppCode","appCode","validCode","validate","multihash","prefix"],"sources":["/Users/tanvisangale/Documents/Project2/Healthcare System/node_modules/multihashes/src/index.js"],"sourcesContent":["/**\n * Multihash implementation in JavaScript.\n *\n * @module multihash\n */\n'use strict'\n\nconst { Buffer } = require('buffer')\nconst multibase = require('multibase')\nconst varint = require('varint')\nconst cs = require('./constants')\n\nexports.names = cs.names\nexports.codes = cs.codes\nexports.defaultLengths = cs.defaultLengths\n\n/**\n * Convert the given multihash to a hex encoded string.\n *\n * @param {Buffer} hash\n * @returns {string}\n */\nexports.toHexString = function toHexString (hash) {\n  if (!Buffer.isBuffer(hash)) {\n    throw new Error('must be passed a buffer')\n  }\n\n  return hash.toString('hex')\n}\n\n/**\n * Convert the given hex encoded string to a multihash.\n *\n * @param {string} hash\n * @returns {Buffer}\n */\nexports.fromHexString = function fromHexString (hash) {\n  return Buffer.from(hash, 'hex')\n}\n\n/**\n * Convert the given multihash to a base58 encoded string.\n *\n * @param {Buffer} hash\n * @returns {string}\n */\nexports.toB58String = function toB58String (hash) {\n  if (!Buffer.isBuffer(hash)) {\n    throw new Error('must be passed a buffer')\n  }\n\n  return multibase.encode('base58btc', hash).toString().slice(1)\n}\n\n/**\n * Convert the given base58 encoded string to a multihash.\n *\n * @param {string|Buffer} hash\n * @returns {Buffer}\n */\nexports.fromB58String = function fromB58String (hash) {\n  let encoded = hash\n  if (Buffer.isBuffer(hash)) {\n    encoded = hash.toString()\n  }\n\n  return multibase.decode('z' + encoded)\n}\n\n/**\n * Decode a hash from the given multihash.\n *\n * @param {Buffer} buf\n * @returns {{code: number, name: string, length: number, digest: Buffer}} result\n */\nexports.decode = function decode (buf) {\n  if (!(Buffer.isBuffer(buf))) {\n    throw new Error('multihash must be a Buffer')\n  }\n\n  if (buf.length < 2) {\n    throw new Error('multihash too short. must be > 2 bytes.')\n  }\n\n  const code = varint.decode(buf)\n  if (!exports.isValidCode(code)) {\n    throw new Error(`multihash unknown function code: 0x${code.toString(16)}`)\n  }\n  buf = buf.slice(varint.decode.bytes)\n\n  const len = varint.decode(buf)\n  if (len < 0) {\n    throw new Error(`multihash invalid length: ${len}`)\n  }\n  buf = buf.slice(varint.decode.bytes)\n\n  if (buf.length !== len) {\n    throw new Error(`multihash length inconsistent: 0x${buf.toString('hex')}`)\n  }\n\n  return {\n    code: code,\n    name: cs.codes[code],\n    length: len,\n    digest: buf\n  }\n}\n\n/**\n *  Encode a hash digest along with the specified function code.\n *\n * > **Note:** the length is derived from the length of the digest itself.\n *\n * @param {Buffer} digest\n * @param {string|number} code\n * @param {number} [length]\n * @returns {Buffer}\n */\nexports.encode = function encode (digest, code, length) {\n  if (!digest || code === undefined) {\n    throw new Error('multihash encode requires at least two args: digest, code')\n  }\n\n  // ensure it's a hashfunction code.\n  const hashfn = exports.coerceCode(code)\n\n  if (!(Buffer.isBuffer(digest))) {\n    throw new Error('digest should be a Buffer')\n  }\n\n  if (length == null) {\n    length = digest.length\n  }\n\n  if (length && digest.length !== length) {\n    throw new Error('digest length should be equal to specified length.')\n  }\n\n  return Buffer.concat([\n    Buffer.from(varint.encode(hashfn)),\n    Buffer.from(varint.encode(length)),\n    digest\n  ])\n}\n\n/**\n * Converts a hash function name into the matching code.\n * If passed a number it will return the number if it's a valid code.\n * @param {string|number} name\n * @returns {number}\n */\nexports.coerceCode = function coerceCode (name) {\n  let code = name\n\n  if (typeof name === 'string') {\n    if (cs.names[name] === undefined) {\n      throw new Error(`Unrecognized hash function named: ${name}`)\n    }\n    code = cs.names[name]\n  }\n\n  if (typeof code !== 'number') {\n    throw new Error(`Hash function code should be a number. Got: ${code}`)\n  }\n\n  if (cs.codes[code] === undefined && !exports.isAppCode(code)) {\n    throw new Error(`Unrecognized function code: ${code}`)\n  }\n\n  return code\n}\n\n/**\n * Checks wether a code is part of the app range\n *\n * @param {number} code\n * @returns {boolean}\n */\nexports.isAppCode = function appCode (code) {\n  return code > 0 && code < 0x10\n}\n\n/**\n * Checks whether a multihash code is valid.\n *\n * @param {number} code\n * @returns {boolean}\n */\nexports.isValidCode = function validCode (code) {\n  if (exports.isAppCode(code)) {\n    return true\n  }\n\n  if (cs.codes[code]) {\n    return true\n  }\n\n  return false\n}\n\n/**\n * Check if the given buffer is a valid multihash. Throws an error if it is not valid.\n *\n * @param {Buffer} multihash\n * @returns {undefined}\n * @throws {Error}\n */\nfunction validate (multihash) {\n  exports.decode(multihash) // throws if bad.\n}\nexports.validate = validate\n\n/**\n * Returns a prefix from a valid multihash. Throws an error if it is not valid.\n *\n * @param {Buffer} multihash\n * @returns {undefined}\n * @throws {Error}\n */\nexports.prefix = function prefix (multihash) {\n  validate(multihash)\n\n  return multihash.slice(0, 2)\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script"}